1. Execution Context
 --  এক্সিকিউশন কন্টেক্সট একটি এনভাইরনমেন্ট যেখানে জাভাস্ক্রিপ্ট কোড এক্সিকিউট করা হয়। যখনই জাভাস্ক্রিপ্টে কোন কোড রান করা হয়, এটি একটি এক্সিকিউশন কন্টেক্সটের মধ্যে রান করা হয়।

three type of Execution context.
 -- Global Execution context
 -- Functional Execution context
 -- Eval Execution context

Every Execution context have two phase

 -- creation Phase
    Global Execution Context
    -- Window:Global Object
    -- this: window
    -- a: undefined
    -- multByTen:fn()
    -- results: undefined
 -- Execution phase

2. Scope কি
-- Scope মূলত একটা নির্দিষ্ট সীমানাকে বোঝায়। যার বাহিরে Variable এবং Function-গুলো এক্সেসিবল না। যদি এই সীমানার বাহিরে কোন Variable এবং Function কে কল করা হয় তাহলে তার কোন অস্তিত্ব থাকবে না। একটি কথা ভাল করে মাথায় সংরক্ষণ করে রাখেন যে, জাভাস্ক্রিপ্টে একমাত্র তখনই Scope তৈরি হয়, যখন আমরা কোন function ইনভোক বা কল করি। হ্যাঁ, function ছাড়া আর কোথাও Scope তৈরি হয় না। আর এই Scope হচ্ছে দুই প্রকার- ১. Global Scope এবং ২. Local Scope।

-- Global Scope
 জাভাস্ক্রিপ্টে বাই ডিফল্ট সব কিছু Global Scope - এ রান হয়। যার এক্সেসিবল সব জায়গায় থাকে। উদাহরণস্বরূপ-

var globalVariable = "I am global variable.";
console.log(globalVariable); // I am global variable.

var myFunc = function () {
  console.log(globalVariable);
};

myFunc(); // I am global variable.

-- Local Scope
আগেই বলেছিলাম যে, জাভাস্ক্রিপ্ট একমাত্র তখনই Scope তৈরি করে যখন কোন Function কে ইনভোক বা কল করা হয়। এই Scope কেই বলা হয় Local Scope। মানে হচ্ছে, তার ভিতরে যা কিছু থাকবে তার নিজস্ব Scope - এর বাহিরে এর কোন অস্তিত্ব থাকবে না। অর্থাৎ, তার Scope - এর ভিতরে লেখা কোন ভেরিয়েবলকে যদি আমরা বাহিরে অন্য কোথাও ব্যবহার করতে চাই তাহলে জাভাস্ক্রিপ্ট খুব সুন্দর করে একটি আনকট রেফারেন্সে ইরর দিয়ে বলে দিবে যে খোকা তুমি যাকে ব্যবহার করতে চাচ্ছ সে তো কোথাও ডিফাইন করা নেই। চলুন একটা উদাহরণ দিয়ে দেখা যাক-

var globalVariable = "I am global variable.";

var myFunc = function () {
  var localVariable = "I am local variable.";

  console.log(globalVariable);
  console.log(localVariable);
};

myFunc();
// I am global variable.
// I am local variable.

console.log(localVariable); // undefined

-- Lexical Scoping কি?
এখন সবার মনে প্রশ্ন আসতে পারে যে, এই Lexical Scoping - টা আবার কি? একটু অপেক্ষা করেন মাথা গরম করার কোন দরকার নেই। আসলে জাভাস্ক্রিপ্টকে বলা হয় Lexical Scoping ল্যাঙ্গুয়েজ। আমরা ফাংশনের ভিতরে আমাদের প্রয়োজন অনুযায়ী একাধিক ফাংশন তৈরি করতে পারি এবং চাইল্ড ফাংশনগুলো তার প্যারেন্ট ফাংশনের সব ভেরিয়েবলস এবং আর্গুমেন্টেসের এক্সেস পায়। কিন্তু আউটার ফাংশনগুলো তার চাইল্ড ফাংশনের ভেরিয়াবলস এবং আর্গুমেন্টসের কোন এক্সেস পায় না। এই যে চাইল্ড ফাংশনগুলো তার প্যারেন্ট ফাংশনের ভেরিয়েবলস এবং আর্গুমেন্টেসের এক্সেস পাচ্ছে এই এক্সেস পাওয়াকেই বল হয় Lexical Scoping।

function outerFunc(a) {
  var outerFuncVariable = "Hi there, I am outer " + a;

  console.log(outerFuncVariable); // Hi there, I am outer function variable

  function innerFunc() {
    var innerFuncVariable = "Hi there, I am inner " + a;
    console.log(innerFuncVariable); // Hi there, I am inner function variable
  }

  innerFunc(); 

  console.log(innerFuncVariable); // undefined
}

outerFunc("function variable");

Note:- 
-- জাভাস্ক্রিপ্টের গ্লোবাল স্কোপ এবং লোকাল স্কোপ আছে।
-- যে কোন ফাংশনের বাইরে ডিক্লেয়ারড এবং ইনিশিয়ালাইজড ভ্যারিয়েবলগুলো গ্লোবাল ভ্যারিয়েবল হয়ে যায়।
-- ফাংশনের ভিতরে ডিক্লেয়ারড এবং ইনিশিয়ালাইজড ভ্যারিয়েবলগুলো সেই ফাংশনের লোকাল ভ্যারিয়েবল হয়।
-- গ্লোবাল ভ্যারিয়েবলগুলো প্রোগ্রামের যেকোন জায়গায় অ্যাক্সেস এবং পরিবর্তন করা যেতে পারে।
-- ফাংশন ডিক্লেয়ারেশনের বাইরে লোকাল ভ্যারিয়েবল সমূহ অ্যাক্সেস করা যাবে না।
-- গ্লোবাল ভ্যারিয়েবল এবং লোকাল ভ্যারিয়েবল একই নাম থাকতে পারে। কিন্তু একই নাম ব্যবহার না করায় ভালো।

3. Hoisting কি
--Hoisting হচ্ছে জাভাস্ক্রিপ্ট এমন একটি পদ্ধতি যেখানে কোড এক্সিকিউশন করার আগে ভ্যারিয়েবল এবং ফাংশন ডিক্লেয়ারেশনগুলোকে তার বর্তমান Scope - এর শুরুতে নিয়ে যায়।

function hoisting() {
 console.log(message);
 var message='Hi there, We are learning Hoisting!'
}

hoisting(); // Ouput: undefined

উদাহরণের ব্যাখ্যা দেওয়ার আগে Hoisting সম্পর্কে কিছু কথা বলে নেই। যখন আমরা কাউকে Hoisting বুঝায় উপরের সংজ্ঞাটা দিয়েই বুঝায়। কিন্তু আসলেই কি জাভাস্ক্রিপ্ট তার সকল ভ্যারিয়েবলস এবং ফাংশন ডিক্লেয়ারেশনগুলোকে তার স্কোপের উপরে নিয়ে যায়? না, জাভাস্ক্রিপ্ট এমনটা কখনো করে না। যদি আপনি আমার Execution Context নিয়ে লেখাটা পড়ে থাকেন, তাহলে আপনি জানেন যে যখন আপনি জাভাস্ক্রিপ্টের কোন কোড এক্সিকিউট করেন, জাভাস্ক্রিপ্ট ইঞ্জিন গ্লোবাল এক্সিকিউশন কন্টেক্সট তৈরি করে।

গ্লোবাল এক্সিকিউশন কন্টেক্সট এর দুটি phase আছে: creation এবং execution। creation phase চলার সময়, জাভাস্ক্রিপ্ট ইঞ্জিন সকল ভ্যারিয়েবলকে undefined হিসাবে ইনিশিয়ালাইজ করে। এবার চলুন আমরা Hoisting-এ ফিরে যাই।

জাভাস্ক্রিপ্টে Hoisting হচ্ছে দুই প্রকার। ১. Variable Hoisting এবং ২. Function Hoisting।

-- Variable Hoisting

console.log(hoistingIntro); // Outpur: undefined

var hoistingIntro = "Hi there, I am a string one.";

উপরের console.log এর আউটপুট কি হবে? একটু চিন্তা করুন সময় নিয়ে। যাইহোক, উপরের কোডে কোন ভুল নেই। কারণ আমরা জানি জাভাস্ক্রিপ্ট ইঞ্জিন Creation phase-এ ভ্যারিয়েবল ডিক্লেয়ারেশনকে undefined হিসাবে ইনিশিয়ালাইজ করে। তাই, Execution phase-এ আউটপুট undefined হচ্ছে কারণ আমরা তার ভ্যালু ইনিশিয়ালাইজ হওয়ার আগেই log করে ফেলেছি। টেকনিক্যালি, কোডটি Execution phase-এ নিম্নলিখিত কোডের মত দেখাবেঃ

var hoistingIntro = undefined;

console.log(hoistingIntro); // output: undefined
hoistingIntro = "Hi there, I am a string one.";

-- Functions Hoisting
ভ্যারিয়েবলের মত ফাংশনও Hoisted হয়। তাই আপনি আগে ফাংশন কল করে পরে ফাংশন ডিক্লেয়ার করতে পারবেন।

hoistedFunc(); // Hoisted

function hoistedFunc() {
 console.log("Hoisted.");
}

বিঃ দ্রঃ একটি কথা ভাল করে মনে রাখবেন যে জাভাস্ক্রিপ্ট ফানশন এক্সপ্রেশনের ক্ষেত্রে কোন Hoisting করে না।
hoistedFunEx(); // TypeError: hoistedFunEx is not a function

var hoistedFunEx = function() {
 console.log("Hoisted.");
}

আপনাদের জন্যে একটি হোম টাস্ক। নিচের কোডের দুইটা console.log এর আউটপুট কি হবে? চাইলে কমেন্ট করে জানাতে পারেন।

var hoistingIntro = "Hi there, I am a string one.";

function hoistingFunc() {
  console.log(hoistingIntro);
  var hoistingIntro = "Hi there, I am a string two";
  console.log(hoistingIntro);
}

hoistingFunc();

4. ক্লোজার কি?

Closure কোন ফাংশন না আবার ফাংশনও কোন closure না। Closure হচ্ছে ফাংশনের এমন একটা বৈশিষ্ট্য যে বৈশিষ্ট্যের কারণে ফাংশন এক্সিকিউশন শেষ হয়ে যাবার পরেও তার lexical scope এ অবস্থিত সকল variable কে মনে রাখতে পারে। উদাহরণস্বরূপ বলা যেতে পারে যে ডম থেকে কিছু অ্যাক্সেস করার জন্যে আমরা যে ইভেন্ট ফাইয়ার করি সেটাও একটা closure

function add(a) {
  return function (b) {
    return a + b;
  };
}

let addTen = add(10);
let addSeven = addTen(7);

console.log(addSeven); // 17

--  যখন add ফাংশনটি কল হয় এটি আরেকটি ফাংশনকে return করে
-- ঐ ফাংশনটির এক্সিকিউশন শেষ হয়ে যায় এবং মনে রাখে ঐ সময় তার প্যারামিটার a এর ভ্যালু কি ছিল
-- যখন addTen ভেরিয়েবলে add ফাংশনকে এসাইন করা হয়। এটি সব সময় মনে রাখবে a এর ভেল্যু কি ছিল যখন এটিকে ইনিশিয়ালি কল করা হয়েছিল।
--উপরের addTen ভেরিয়েবল একটি ফাংশনকে বোঝায় যেটি সব সময় ভেল্যু ১০ যোগ করবে যা পাঠানো হয়েছিল
--তার মানে হল যখন addTen কে কল করা হয় ৭ ভেল্যু দিয়ে, এটি ১০ এর সাথে ৭ যোগ করবে এবং ১৭ রিটার্ন করবে

-- সুতারং, জাভাস্ক্রিপ্ট ইঞ্জিন addTen কে যেভাবে রান করেঃ
function addTen(b) {
  return 10 + b;
}

--এখন একটা মজার উদাহরণ দেখবো। কিভাবে আমরা লুপের ভিতরে ক্লোজার চালাতে পারি। এটি ইন্টার্ভিউ বোর্ডের একটা কমন প্রশ্ন। নিচের কোডটা দেখেন এবং একটু মনে মনে চিন্তা করেন এটার আউটপুট কত হবে।

for (var i = 1; i <= 5; i++) {
  setTimeout(() => console.log(i), 1000);
}

--কাঙ্ক্ষিত আউটপুটঃ
1
2
3
4
5

--কিন্তু আসছে অনাকাঙ্ক্ষিত আওউটপুটঃ-
6
6
6
6
6

--আসলে এই আউটপুট আসার অনেক কারণ আছে। লুপের মাঝে ভ্যারিয়াবল i হচ্ছে একটি গ্লোবাল ভ্যারিয়াবল। যখন setTimeout রান হয় তার আগেই লুপ শেষ হয়ে যায় এবং তাই i ভ্যালু 6 হয়ে যায়। সেজন্যে প্রতি এক সেকন্ড পর পর পাঁচবার 6 দেখাচ্ছে। যদি বিশ্বাস না হয় তাহলে কোডটা রান করার পর আপনার গ্লোবাল window অবজেক্টটা একবার দেখেন সেখানে i নামে একটা ভ্যারিয়াবল দেখতে পারবেন এবং তার ভ্যালু 6 হয়ে আছে।

এই সমস্যার সমাধান আমরা IIFE বা Immediately Invoked Function Expression ব্যবহার করে করতে পারি। নিচে উদাহরণ দেওয়া হলঃ-

পদ্ধতি ১ঃ-
for (var i = 1; i <= 5; i++) {
  (function () {
    var val = i;
    setTimeout(() => console.log(val), 1000);
  })();
}

পদ্ধতি ২ঃ
for (var i = 1; i <= 5; i++) {
  (function (val) {
    setTimeout(() => console.log(val), 1000);
  })(i);
}

পদ্ধতি ৩ঃ
for (let i = 1; i <= 5; i++) {
  setTimeout(() => console.log(i), 1000);
}

আউটপুটঃ-
1
2
3
4
5

এখানে আমরা একটা ফাংশন লিখে একটা Scope তৈরি করেছি। ফাংশনটিকে ইমিডিয়েটলি কল করেছি এবং তার প্যারামিটারের ভেল্যু হিসাবে i কে পাস করেছি। এতে সে এখন i এর ভেল্যুকে মনে না রেখে সে এখন তার প্যারামিটারের ভেল্যুকে মনে রাখবে। মানে এখন i এর মান 1, 2 করে যাচ্ছে এবং সেটা থেকে একটা আলাদা Scope তৈরি হচ্ছে যেটাকে সে মনে রাখছে।

পদ্ধতি ৩ঃ
for (let i = 1; i <= 5; i++) {
  setTimeout(() => console.log(i), 1000);
}

5. আজকে আমরা আলোচনা করতে যাচ্ছি Primitive এবং Reference টাইপ ডাটার মাঝে কি পার্থক্য এবং এই ডাটা টাইপগুলো কিভাবে কাজ করে। Primitive এবং Reference টাইপকে pass by value এবং pass by reference ও বলা হয়ে থাকে। একজন জাভাস্ক্রিপ্ট প্রোগ্রামার হিসাবে এই ডাটা টাইপগুলো সম্পর্কে পরিষ্কার জ্ঞান রাখা আবশ্যক।

জাভাস্ক্রিপ্টে দুই টাইপের ডাটা টাইপ আছে।

primitive ডাটা টাইপ এবং
non-primitive বা reference ডাটা টাইপ
জাভাস্ক্রিপ্টে Strings, Numbers, Boolean, Null, undefined এই ডাটা টাইপগুলো প্রিমিটিভ ডাটা টাইপ হিসাবে পরিচিত এবং Arrays, Objects, Function নন-প্রিমিটিভ বা রেফারেন্স ডাটা টাইপ হিসাবে পরিচিত। এদের মাঝে মৌলিক পার্থক্য হচ্ছে যে প্রিমিটিভ ডাটা immutable বা অপরিবর্তনীয় এবং নন-প্রিমিটিভ ডাটা mutable বা পরিবর্তনীয়।

-- প্রিমিটিভ ডাটা টাইপ
-- প্রমিটিভ ডাটা immutable বা অপরিবর্তনীয় ডাটা টাইপ হিসাবে পরিচিত। কারণ এই ডাটা একবার তৈরি হয়ে গেলে এটি পরিবর্তন করার কোন পথ নেই। তাহলে চলেন আপনাদের প্রমাণ করে দেখাই।

let str1 = "Hi there, I am a string!";
console.log(str1[1]); // "i"
	
str1[1] = "e";
console.log(str1); // "Hi there, I am a string!"

উপরের কোডটা রান করলে জাভাস্ক্রিপ্টের কারিশমা দেখতে পারবেন। সব কিছু মাথার উপর দিয়ে গেল? আচ্ছা, চলেন ব্যাপারটা ব্যাখ্যা করি। আপনি হাজার বার চাইলেও স্ট্রিং এর ভ্যালু পরিবর্তন করতে পারবেন না। কারণ স্ট্রিং একটি immutable বা অপরিবর্তনীয় ডাটা। একটি কথা মনে রাখবেন যদি স্ট্রিংকে কোন ভেরিয়েবলে অ্যাসাইন করে ফেলেন এবং অ্যাসাইন করার পর স্ট্রিংকে মডিফাই করতে চান, তাহলে আপনি একটি নতুন স্ট্রিং পাবেন। যেমন- .toUpperCase(), .slice(), .trim() ইত্যাদি।

let str1 = "Hi there, I am a string!";
let newStr = str1.toUpperCase();
	
console.log(newStr); // HI THERE, I AM A STRING!
console.log(str1); Hi there, I am a string!

প্রিমিটিভ ডাটা টাইপগুলো একে অপরের সাথে তাদের ভ্যালু দ্বারা তুলনা করে।

let str1 = "Hi there, I am a string!";
let str2 = "Hi there, I am a string!";
	
console.log(str1 == str2); // true
	
let num1 = 7;
let num2 = 7;
	
console.log(num1 == num2); // true

প্রিমিটিভ টাইপগুলো সব সময় তাদের ভ্যালু পাস করে। যখন আমরা কোন প্রিমিটিভ ডাটা টাইপকে অন্য কোন ভেরিয়েবলে অ্যাসাইন করি, তখন তার ভ্যালু কপি হয়ে নতুন ভেরিয়েবলে অ্যাসাইন হয়।

let num1 = 7;
let num2 = num1;
	
console.log(num1); // 7
console.log(num2); // 7
	
num2 = 8;
	
console.log(num1); // 7
console.log(num2); // 8

--নন-প্রিমিটিভ ডাটা টাইপ 

নন-প্রিমিটিভ ডাটা mutable বা পরিবর্তনীয়। কারণ একটি নন-প্রিমিটিভ ডাটা তৈরি হয়ে যাওয়ার পরেও তার ভ্যালু পরিবর্তন হতে পারে। আমরা যখন কোন নন-প্রিমিটিভ ডাটা তৈরি করি, তখন সেই ডাটার জন্যে মেমোরিতে একটা অ্যাড্রেস তৈরি হয় এবং সেই অ্যাড্রেসটাকে মনে রেখে কোন এক জায়গায় ভ্যালুগুলোকে স্ট্রোর করে রাখে। তারপর আমাদের যখন দরকার পরে তখন সে ঐ অ্যাড্রেসকে কল করে এবং আমাদের ডাটা প্রদান করে। এটা বুঝতে হলে আপনাকে স্ট্যাক এবং হীপ মেমোরি সম্পর্কে জানতে হবে। তবে আমি যতটুকু বললাম এখন এতটুকু মনে রাখলেই হবে।

let arr1 = ["JavaScript", "React", "Redux", "React-Redux"];
let arr2 = arr1;
	
console.log(arr1); // ["JavaScript", "React", "Redux", "React-Redux"]
console.log(arr2); // ["JavaScript", "React", "Redux", "React-Redux"]
	
arr2[3] = "Redux-Toolkit";
console.log(arr1); // ["JavaScript", "React", "Redux", "Redux-Toolkit"]
console.log(arr2); // ["JavaScript", "React", "Redux", "Redux-Toolkit"]

নন-প্রিমিটিভ বা রেফারেন্স ডাটাগুলো সব সময় তাদের রেফারেন্স পাস করে। যখন আমরা কোন রেফারেন্স ডাটাকে অন্য কোন ভেরিয়েবলে অ্যাসাইন করি, তখন তার রেফারেন্স কপি হয়। মানে arr1 কে যখন আমরা arr2 তে অ্যাসাইন করি তখন তার রেফারেন্স বা অ্যাড্রেসটাকে কপি করে বা মনে রাখে তার ভ্যালুকে না। তাই দুইটা ভেরিয়েবলের অ্যাড্রেস একই থাকে। তাই যখন আমরা কোন একটি ভেরিয়েবলের ভ্যালু পরিবর্তন করি, তখন দুইটা ভেরিয়েবলেরই ভ্যালু পরিবর্তন হয়ে যায়।

let obj1 = {
 name: 'JavaScript'
};
let obj2 = obj1;
	
console.log(`${obj1.name}`); // JavaScript
console.log(`${obj2.name}`); // JavaScript
	
obj2.name = "React";
	
console.log(`${obj1.name}`); // React
console.log(`${obj2.name}`); // React

আশা করি, উপরের কোডে কি হচ্ছে সেটা এখন খুব ভাল ভাবেই বুঝতে পারছেন। একটি কথা নন-প্রিমিটিভ ডাটা তাদের রেফারেন্স দ্বারা তুলনা করে।

let obj1 = {
 name: 'JavaScript'
};
	
let obj2 = {
 name: 'React'
};
	
console.log(obj1 === obj2); // false

এখানে দুইটা অবজেক্টের একই ভ্যালু কিন্তু যখন আমরা দুইটা অবজেক্টকে একে-অপরের সাথে তুলনা করছি, তখন তারা false রিটার্ন করছে। কারণ তাদের ভ্যালু একই হলেও তাদের অ্যাড্রেস এক না।

let obj1 = {
 name: 'JavaScript'
};
	
let obj2 = obj1;
	
console.log(obj1 === obj2); // true

6. কলব্যাক ফাংশন কি?

-- সহজ কথায়, কলব্যাক ফাংশন হচ্ছে এমন একটি ফাংশন যেটি অন্য একটি ফাংশনে আর্গুমেন্ট হিসাবে পাস করা ফাংশন, যেটি কোন কাজ সম্পন্ন করার জন্যে আউটার ফাংশনের ভিতরে ইনভোক হয়।

-- হাইয়ার অর্ডার ফাংশন কি?
-- যে ফাংশনে অন্য কোন ফাংশনকে আর্গুমেন্ট হিসাবে পাস করা হয় বা কোন ফাংশন অন্য কোন ফাংশনকে রিটার্ন করে তাকে হাইয়ার অর্ডার ফাংশন বলা হয়।

আমাদের এমন একটি ফাংশন আছে যেটি আর্গুমেন্ট হিসেবে একটি অ্যারে নিবে এবং সেটি কে মডিফাই করে একটি নতুন অ্যারে রিটার্ন করবে। এক্ষেত্রে, আমাদের ফাংশনটিকে যে অ্যারে দেওয়া হবে তার সাথে দুই যোগ করে নতুন একটি অ্যারে রিটার্ন করবে

function multifyBy2(arr) {
 let output = [];
	
 for(let i = 0; i < arr.length; i++) {
   output.push(arr[i] * 2);
 }
	
 return output;
}

const newArr = modifyBy2([1,2,3,4,5,6]);
console.log(newArr); // [2, 4, 6, 8, 10, 12]

এখন যদি আমরা বিয়োগ বা ভাগ করতে চাই? তাহলে আমাদেরকে আরও দুটি ফাংশন লিখতে হবে তাই না? ব্যাপারটা তাহলে কি ভাল কিছু হচ্ছে? কোড রিপিটেশন হয়ে যাচ্ছে। একটি বিষয় লক্ষ্য করেন আমাদের লেখা দুটি ফাংশনেই শুধু অপারেশনগুলা ছাড়া একই কোড লিখেছি। আমরা যদি এমন কিছু করতে পারি যে আমাদের ফাংশনে যোগ, বিয়োগ যে কাজই করুক না কেন সেটি আমরা বলে দিবো, তাহলে কেমন হয়? এখন আমরা সে কাজটাই করবো। তার জন্যে আমাদেরকে আমাদের ফাংশনের সাথে আরেকটি আর্গুমেন্ট পাস করতে হবে। যেটি আসলে আমাদের অপারেশনটা হ্যান্ডেল করবে।

function modifyArray(arr, fn) {
 let output = [];
	
 for(let i = 0; i < arr.length; i++) {
   output.push(fn(arr[i]));
	}
	
	return output;
}

function modifyBy2(elem) {
	return elem + 2;
}


const newArr = modifyArray([1,2,3,4,5,6], modifyBy2);
console.log(newArr); // [3, 4, 5, 6, 7, 8]

উপরের কোডে লক্ষ্য করুন, আমরা modifyArray নামে একটি ফাংশন ডিফাইন করেছি যেটি দুটি আর্গুমেন্টস নিচ্ছে। একটি অ্যারে এবং অন্যটি একটি ফাংশন। সে ফাংশনে আমরা বলে দিচ্ছি তার কাজ কি হবে। সে তার কাজ সম্পন্ন করে output অ্যারেতে তার ভ্যালুটা পুশ করে দিচ্ছে এবং modifyArray ফাংশনটি কাজ সম্পন্ন করে একটি নতুন অ্যারে রিটার্ন করতেছে। এখন যদি আমরা বিয়োগ, গুণ বা ভাগ করতে চাই সেটিও খুব সহজেই করতে পারবো এই ফাংশন দিয়ে। আমাদেরকে নতুন করে কোন লজিক লেখা লাগবে না শুধু আমরা একটি নতুন ফাংশন দিয়ে দিবো এবং সেখানে বলে দিবো তাকে কি করতে হবে। তাহলে চলুন দেখি আমাদের কাজ করতে পারি কিনা।

function modifyArray(arr, callback) {
	let output = [];
	
	for(let i = 0; i < arr.length; i++) {
		output.push(callback(arr[i]));
	}
	
	return output;
}

function addBy2(elem) {
	return elem + 2;
}

function multifyBy2(elem) {
	return elem * 2;
}


const additionArr = modifyArray([1,2,3,4,5,6], addBy2);
const multiArr = modifyArray([1,2,3,4,5,6], multifyBy2);

console.log(additionArr); // [3, 4, 5, 6, 7, 8]
console.log(multiArr); // [2, 4, 6, 8, 10, 12]

modifyArray ফাংশনটিতে আর্গুমেন্ট হিসাবে যে ফাংশনটিকে পাস করতেছি ওই ফাংশনটিই হচ্ছে একটি কলব্যাক ফাংশন এবং modifyArray ফাংশনটি হচ্ছে একটি হাইয়ার অর্ডার ফাংশন।

7. this-keyword

আজকে আলোচনা করতে যাচ্ছি “this” কিওয়ার্ড নিয়ে। জাভাস্ক্রিপ্টে একটি মারাত্মক ভয়ের নাম হচ্ছে “this”। এটি খুবই গুরুত্বপূর্ণ একটা টার্মস যার সম্পর্কে পরিষ্কার ধারণা থাকা উচিত বলে আমি মনে করি। শুরুর দিকে এটা নিয়ে প্রায় সবাই একটু কনফিউশনে ভুগে। কারণ এটি এক এক সময় এক এক রকম আউটপুট দেয়। আমাদের বুঝতে হবে কেন এবং কখন কি আউটপুট দেয়। আমি চেষ্টা করবো ব্যাপারটাকে যতটা সম্ভব সহজভাবে লেখার জন্যে যাতে করে এই “this” নিয়ে আজকের পর থেকে কারোর কোন প্রকার কনফিউশন না থাকে এবং কারোর মাথার উপর দিয়ে না যায়।

function myFunc() {
    console.log(this);
}

myFunc();

একটু চিন্তা করুন তো এখানে myFunc() ফাংশনটিকে কে কল করতেছে। যদি এইটা ধরতে পারেন তাহলে myFunc() এর আউটপুট কি হবে সেইটাও বুঝতে পারবেন। একটু চিন্তা করুন সময় নিয়ে।

আশা করি, চিন্তা করেছেন এবং ধরতেও পেরেছেন। যদি না পারেন তাহলে কোন সমস্যা নেই। একটা ব্যাপার সব সময় মাথায় রাখবেন যে “this” এর ভ্যালু কি হবে সেটা নির্ভর করে কোথায় এবং কিভাবে কল হচ্ছে তার উপর ভিত্তি করে। উপরের কোডে myFunc() কে কল করতেছে window অবজেক্ট। কারণ ব্রাউজারে সব কিছু বাই ডিফল্ট window অবজেক্টের আন্ডারে রান হয়। তার মানে হচ্ছে যে যার মাধ্যমে কল হবে “this” তাকে দেখাবে আউটপুট হিসাবে।

যেহেতু myFunc() কে window কল করতেছে তাই myFunc() এর ভিতরে থাকা “this” - window এর সব ভ্যালুকে আউটপুট হিসাবে দেখাচ্ছে।

আমরা না অনেক ভাল প্রোগ্রামার। তাই ‘use strict’; মোডে উপরের কোডটি আবার রান করুন এবং দেখুন কি হয়।

8. event-capturing-and-bubbling